// Code generated by goa v3.0.9, DO NOT EDIT.
//
// upload HTTP server encoders and decoders
//
// Command:
// $ goa gen goa.design/examples/tus/design

package server

import (
	"context"
	"io"
	"net/http"
	"strconv"

	upload "goa.design/examples/tus/gen/upload"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// EncodeHeadResponse returns an encoder for responses returned by the upload
// head endpoint.
func EncodeHeadResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*upload.HeadResult)
		w.Header().Set("Tusresumable", res.TusResumable)
		if res.TusVersion != nil {
			w.Header().Set("Tusversion", *res.TusVersion)
		}
		val := res.UploadOffset
		uploadOffsets := strconv.FormatUint(uint64(val), 10)
		w.Header().Set("Uploadoffset", uploadOffsets)
		if res.UploadLength != nil {
			val := res.UploadLength
			uploadLengths := strconv.FormatUint(uint64(*val), 10)
			w.Header().Set("Uploadlength", uploadLengths)
		}
		if res.UploadDeferLength != nil {
			val := res.UploadDeferLength
			uploadDeferLengths := strconv.Itoa(*val)
			w.Header().Set("Uploaddeferlength", uploadDeferLengths)
		}
		if res.UploadMetadata != nil {
			w.Header().Set("Uploadmetadata", *res.UploadMetadata)
		}
		w.WriteHeader(http.StatusOK)
		return nil
	}
}

// DecodeHeadRequest returns a decoder for requests sent to the upload head
// endpoint.
func DecodeHeadRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			id           string
			tusResumable string
			uploadOffset *uint
			err          error

			params = mux.Vars(r)
		)
		id = params["id"]
		err = goa.MergeErrors(err, goa.ValidatePattern("id", id, "[0-9a-f]{32}"))
		tusResumable = r.Header.Get("tusResumable")
		if tusResumable == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("tusResumable", "header"))
		}
		err = goa.MergeErrors(err, goa.ValidatePattern("tusResumable", tusResumable, "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(-(0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(\\.(0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*)?(\\+[0-9a-zA-Z-]+(\\.[0-9a-zA-Z-]+)*)?$"))
		{
			uploadOffsetRaw := r.Header.Get("uploadOffset")
			if uploadOffsetRaw != "" {
				v, err2 := strconv.ParseUint(uploadOffsetRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("uploadOffset", uploadOffsetRaw, "unsigned integer"))
				}
				pv := uint(v)
				uploadOffset = &pv
			}
		}
		if err != nil {
			return nil, err
		}
		payload := NewHeadPayload(id, tusResumable, uploadOffset)

		return payload, nil
	}
}

// EncodeHeadError returns an encoder for errors returned by the head upload
// endpoint.
func EncodeHeadError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "InvalidTusResumable":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewHeadInvalidTusResumableResponseBody(res)
			}
			w.Header().Set("goa-error", "InvalidTusResumable")
			w.WriteHeader(http.StatusPreconditionFailed)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodePatchResponse returns an encoder for responses returned by the upload
// patch endpoint.
func EncodePatchResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*upload.PatchResult)
		w.Header().Set("Tusresumable", res.TusResumable)
		if res.TusVersion != nil {
			w.Header().Set("Tusversion", *res.TusVersion)
		}
		val := res.UploadOffset
		uploadOffsets := strconv.FormatUint(uint64(val), 10)
		w.Header().Set("Uploadoffset", uploadOffsets)
		if res.UploadExpires != nil {
			w.Header().Set("Uploadexpires", *res.UploadExpires)
		}
		w.WriteHeader(http.StatusNoContent)
		return nil
	}
}

// DecodePatchRequest returns a decoder for requests sent to the upload patch
// endpoint.
func DecodePatchRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body []byte
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}

		var (
			id             string
			tusResumable   string
			uploadOffset   uint
			uploadChecksum *string

			params = mux.Vars(r)
		)
		id = params["id"]
		err = goa.MergeErrors(err, goa.ValidatePattern("id", id, "[0-9a-f]{32}"))
		tusResumable = r.Header.Get("tusResumable")
		if tusResumable == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("tusResumable", "header"))
		}
		err = goa.MergeErrors(err, goa.ValidatePattern("tusResumable", tusResumable, "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(-(0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(\\.(0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*)?(\\+[0-9a-zA-Z-]+(\\.[0-9a-zA-Z-]+)*)?$"))
		{
			uploadOffsetRaw := r.Header.Get("uploadOffset")
			if uploadOffsetRaw == "" {
				err = goa.MergeErrors(err, goa.MissingFieldError("uploadOffset", "header"))
			}
			v, err2 := strconv.ParseUint(uploadOffsetRaw, 10, strconv.IntSize)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("uploadOffset", uploadOffsetRaw, "unsigned integer"))
			}
			uploadOffset = uint(v)
		}
		uploadChecksumRaw := r.Header.Get("uploadChecksum")
		if uploadChecksumRaw != "" {
			uploadChecksum = &uploadChecksumRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewPatchPayload(body, id, tusResumable, uploadOffset, uploadChecksum)

		return payload, nil
	}
}

// EncodePatchError returns an encoder for errors returned by the patch upload
// endpoint.
func EncodePatchError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "InvalidContentType":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewPatchInvalidContentTypeResponseBody(res)
			}
			w.Header().Set("goa-error", "InvalidContentType")
			w.WriteHeader(http.StatusUnsupportedMediaType)
			return enc.Encode(body)
		case "InvalidOffset":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewPatchInvalidOffsetResponseBody(res)
			}
			w.Header().Set("goa-error", "InvalidOffset")
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "NotFound":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewPatchNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", "NotFound")
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "InvalidChecksumAlgorithm":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewPatchInvalidChecksumAlgorithmResponseBody(res)
			}
			w.Header().Set("goa-error", "InvalidChecksumAlgorithm")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "ChecksumMismatch":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewPatchChecksumMismatchResponseBody(res)
			}
			w.Header().Set("goa-error", "ChecksumMismatch")
			w.WriteHeader(460)
			return enc.Encode(body)
		case "InvalidTusResumable":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewPatchInvalidTusResumableResponseBody(res)
			}
			w.Header().Set("goa-error", "InvalidTusResumable")
			w.WriteHeader(http.StatusPreconditionFailed)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeOptionsResponse returns an encoder for responses returned by the
// upload options endpoint.
func EncodeOptionsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*upload.OptionsResult)
		w.Header().Set("Tusresumable", res.TusResumable)
		w.Header().Set("Tusversion", res.TusVersion)
		w.Header().Set("Tusextension", res.TusExtension)
		if res.TusMaxSize != nil {
			val := res.TusMaxSize
			tusMaxSizes := strconv.FormatUint(uint64(*val), 10)
			w.Header().Set("Tusmaxsize", tusMaxSizes)
		}
		w.Header().Set("Tuschecksumalgorithm", res.TusChecksumAlgorithm)
		w.WriteHeader(http.StatusNoContent)
		return nil
	}
}

// EncodeOptionsError returns an encoder for errors returned by the options
// upload endpoint.
func EncodeOptionsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "InvalidTusResumable":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewOptionsInvalidTusResumableResponseBody(res)
			}
			w.Header().Set("goa-error", "InvalidTusResumable")
			w.WriteHeader(http.StatusPreconditionFailed)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodePostResponse returns an encoder for responses returned by the upload
// post endpoint.
func EncodePostResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*upload.PostResult)
		w.Header().Set("Location", res.Location)
		w.Header().Set("Tusresumable", res.TusResumable)
		if res.TusVersion != nil {
			w.Header().Set("Tusversion", *res.TusVersion)
		}
		val := res.UploadOffset
		uploadOffsets := strconv.FormatUint(uint64(val), 10)
		w.Header().Set("Uploadoffset", uploadOffsets)
		if res.UploadExpires != nil {
			w.Header().Set("Uploadexpires", *res.UploadExpires)
		}
		w.WriteHeader(http.StatusCreated)
		return nil
	}
}

// DecodePostRequest returns a decoder for requests sent to the upload post
// endpoint.
func DecodePostRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body []byte
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}

		var (
			tusResumable      string
			uploadDeferLength *int
			uploadChecksum    *string
			tusMaxSize        *uint
		)
		tusResumable = r.Header.Get("tusResumable")
		if tusResumable == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("tusResumable", "header"))
		}
		err = goa.MergeErrors(err, goa.ValidatePattern("tusResumable", tusResumable, "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(-(0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(\\.(0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*)?(\\+[0-9a-zA-Z-]+(\\.[0-9a-zA-Z-]+)*)?$"))
		{
			uploadDeferLengthRaw := r.Header.Get("uploadDeferLength")
			if uploadDeferLengthRaw != "" {
				v, err2 := strconv.ParseInt(uploadDeferLengthRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("uploadDeferLength", uploadDeferLengthRaw, "integer"))
				}
				pv := int(v)
				uploadDeferLength = &pv
			}
		}
		if uploadDeferLength != nil {
			if !(*uploadDeferLength == 1) {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("uploadDeferLength", *uploadDeferLength, []interface{}{1}))
			}
		}
		uploadChecksumRaw := r.Header.Get("uploadChecksum")
		if uploadChecksumRaw != "" {
			uploadChecksum = &uploadChecksumRaw
		}
		{
			tusMaxSizeRaw := r.Header.Get("tusMaxSize")
			if tusMaxSizeRaw != "" {
				v, err2 := strconv.ParseUint(tusMaxSizeRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("tusMaxSize", tusMaxSizeRaw, "unsigned integer"))
				}
				pv := uint(v)
				tusMaxSize = &pv
			}
		}
		if err != nil {
			return nil, err
		}
		payload := NewPostPayload(body, tusResumable, uploadDeferLength, uploadChecksum, tusMaxSize)

		return payload, nil
	}
}

// EncodePostError returns an encoder for errors returned by the post upload
// endpoint.
func EncodePostError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "InvalidDeferLength":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewPostInvalidDeferLengthResponseBody(res)
			}
			w.Header().Set("goa-error", "InvalidDeferLength")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "InvalidChecksumAlgorithm":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewPostInvalidChecksumAlgorithmResponseBody(res)
			}
			w.Header().Set("goa-error", "InvalidChecksumAlgorithm")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "MaximumSizeExceeded":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewPostMaximumSizeExceededResponseBody(res)
			}
			w.Header().Set("goa-error", "MaximumSizeExceeded")
			w.WriteHeader(http.StatusRequestEntityTooLarge)
			return enc.Encode(body)
		case "ChecksumMismatch":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewPostChecksumMismatchResponseBody(res)
			}
			w.Header().Set("goa-error", "ChecksumMismatch")
			w.WriteHeader(460)
			return enc.Encode(body)
		case "InvalidTusResumable":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewPostInvalidTusResumableResponseBody(res)
			}
			w.Header().Set("goa-error", "InvalidTusResumable")
			w.WriteHeader(http.StatusPreconditionFailed)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeDeleteResponse returns an encoder for responses returned by the upload
// delete endpoint.
func EncodeDeleteResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*upload.DeleteResult)
		w.Header().Set("Tusresumable", res.TusResumable)
		if res.TusVersion != nil {
			w.Header().Set("Tusversion", *res.TusVersion)
		}
		w.WriteHeader(http.StatusNoContent)
		return nil
	}
}

// DecodeDeleteRequest returns a decoder for requests sent to the upload delete
// endpoint.
func DecodeDeleteRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			id           string
			tusResumable string
			err          error

			params = mux.Vars(r)
		)
		id = params["id"]
		err = goa.MergeErrors(err, goa.ValidatePattern("id", id, "[0-9a-f]{32}"))
		tusResumable = r.Header.Get("tusResumable")
		if tusResumable == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("tusResumable", "header"))
		}
		err = goa.MergeErrors(err, goa.ValidatePattern("tusResumable", tusResumable, "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(-(0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(\\.(0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*)?(\\+[0-9a-zA-Z-]+(\\.[0-9a-zA-Z-]+)*)?$"))
		if err != nil {
			return nil, err
		}
		payload := NewDeletePayload(id, tusResumable)

		return payload, nil
	}
}

// EncodeDeleteError returns an encoder for errors returned by the delete
// upload endpoint.
func EncodeDeleteError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "NotFound":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewDeleteNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", "NotFound")
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "InvalidTusResumable":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewDeleteInvalidTusResumableResponseBody(res)
			}
			w.Header().Set("goa-error", "InvalidTusResumable")
			w.WriteHeader(http.StatusPreconditionFailed)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}
