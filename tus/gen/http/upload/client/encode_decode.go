// Code generated by goa v3.0.9, DO NOT EDIT.
//
// upload HTTP client encoders and decoders
//
// Command:
// $ goa gen goa.design/examples/tus/design

package client

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strconv"

	upload "goa.design/examples/tus/gen/upload"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// BuildHeadRequest instantiates a HTTP request object with method and path set
// to call the "upload" service "head" endpoint
func (c *Client) BuildHeadRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		id string
	)
	{
		p, ok := v.(*upload.HeadPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("upload", "head", "*upload.HeadPayload", v)
		}
		id = p.ID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: HeadUploadPath(id)}
	req, err := http.NewRequest("HEAD", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("upload", "head", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeHeadRequest returns an encoder for requests sent to the upload head
// server.
func EncodeHeadRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*upload.HeadPayload)
		if !ok {
			return goahttp.ErrInvalidType("upload", "head", "*upload.HeadPayload", v)
		}
		req.Header.Set("tusResumable", p.TusResumable)
		if p.UploadOffset != nil {
			req.Header.Set("uploadOffset", *p.UploadOffset)
		}
		return nil
	}
}

// DecodeHeadResponse returns a decoder for responses returned by the upload
// head endpoint. restoreBody controls whether the response body should be
// restored after having been read.
func DecodeHeadResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				tusResumable      string
				uploadOffset      uint
				uploadLength      *uint
				uploadDeferLength *int
				uploadMetadata    *string
				err               error
			)
			tusResumableRaw := resp.Header.Get("Tusresumable")
			if tusResumableRaw == "" {
				err = goa.MergeErrors(err, goa.MissingFieldError("tusResumable", "header"))
			}
			tusResumable = tusResumableRaw
			err = goa.MergeErrors(err, goa.ValidatePattern("tusResumable", tusResumable, "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(-(0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(\\.(0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*)?(\\+[0-9a-zA-Z-]+(\\.[0-9a-zA-Z-]+)*)?$"))
			{
				uploadOffsetRaw := resp.Header.Get("Uploadoffset")
				if uploadOffsetRaw == "" {
					return nil, goahttp.ErrValidationError("upload", "head", goa.MissingFieldError("uploadOffset", "header"))
				}
				v, err2 := strconv.ParseUint(uploadOffsetRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("uploadOffset", uploadOffsetRaw, "unsigned integer"))
				}
				uploadOffset = uint(v)
			}
			{
				uploadLengthRaw := resp.Header.Get("Uploadlength")
				if uploadLengthRaw != "" {
					v, err2 := strconv.ParseUint(uploadLengthRaw, 10, strconv.IntSize)
					if err2 != nil {
						err = goa.MergeErrors(err, goa.InvalidFieldTypeError("uploadLength", uploadLengthRaw, "unsigned integer"))
					}
					pv := uint(v)
					uploadLength = &pv
				}
			}
			{
				uploadDeferLengthRaw := resp.Header.Get("Uploaddeferlength")
				if uploadDeferLengthRaw != "" {
					v, err2 := strconv.ParseInt(uploadDeferLengthRaw, 10, strconv.IntSize)
					if err2 != nil {
						err = goa.MergeErrors(err, goa.InvalidFieldTypeError("uploadDeferLength", uploadDeferLengthRaw, "integer"))
					}
					pv := int(v)
					uploadDeferLength = &pv
				}
			}
			if uploadDeferLength != nil {
				if !(*uploadDeferLength == 1) {
					err = goa.MergeErrors(err, goa.InvalidEnumValueError("uploadDeferLength", *uploadDeferLength, []interface{}{1}))
				}
			}
			uploadMetadataRaw := resp.Header.Get("Uploadmetadata")
			if uploadMetadataRaw != "" {
				uploadMetadata = &uploadMetadataRaw
			}
			if err != nil {
				return nil, goahttp.ErrValidationError("upload", "head", err)
			}
			res := NewHeadResultOK(tusResumable, uploadOffset, uploadLength, uploadDeferLength, uploadMetadata)
			return res, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("upload", "head", resp.StatusCode, string(body))
		}
	}
}

// BuildPatchRequest instantiates a HTTP request object with method and path
// set to call the "upload" service "patch" endpoint
func (c *Client) BuildPatchRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		id string
	)
	{
		p, ok := v.(*upload.PatchPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("upload", "patch", "*upload.PatchPayload", v)
		}
		if p.ID != nil {
			id = *p.ID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: PatchUploadPath(id)}
	req, err := http.NewRequest("PATCH", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("upload", "patch", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodePatchRequest returns an encoder for requests sent to the upload patch
// server.
func EncodePatchRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*upload.PatchPayload)
		if !ok {
			return goahttp.ErrInvalidType("upload", "patch", "*upload.PatchPayload", v)
		}
		req.Header.Set("tusResumable", p.TusResumable)
		req.Header.Set("uploadOffset", p.UploadOffset)
		if p.UploadChecksum != nil {
			req.Header.Set("uploadChecksum", *p.UploadChecksum)
		}
		body := p
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("upload", "patch", err)
		}
		return nil
	}
}

// DecodePatchResponse returns a decoder for responses returned by the upload
// patch endpoint. restoreBody controls whether the response body should be
// restored after having been read.
// DecodePatchResponse may return the following errors:
//	- "InvalidContentType" (type *goa.ServiceError): http.StatusUnsupportedMediaType
//	- "InvalidOffset" (type *goa.ServiceError): http.StatusConflict
//	- "NotFound" (type *goa.ServiceError): http.StatusNotFound
//	- "InvalidChecksumAlgorithm" (type *goa.ServiceError): http.StatusBadRequest
//	- "ChecksumMismatch" (type *goa.ServiceError): 460
//	- error: internal error
func DecodePatchResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			var (
				tusResumable  string
				uploadOffset  uint
				uploadExpires *string
				err           error
			)
			tusResumableRaw := resp.Header.Get("Tusresumable")
			if tusResumableRaw == "" {
				err = goa.MergeErrors(err, goa.MissingFieldError("tusResumable", "header"))
			}
			tusResumable = tusResumableRaw
			err = goa.MergeErrors(err, goa.ValidatePattern("tusResumable", tusResumable, "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(-(0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(\\.(0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*)?(\\+[0-9a-zA-Z-]+(\\.[0-9a-zA-Z-]+)*)?$"))
			{
				uploadOffsetRaw := resp.Header.Get("Uploadoffset")
				if uploadOffsetRaw == "" {
					return nil, goahttp.ErrValidationError("upload", "patch", goa.MissingFieldError("uploadOffset", "header"))
				}
				v, err2 := strconv.ParseUint(uploadOffsetRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("uploadOffset", uploadOffsetRaw, "unsigned integer"))
				}
				uploadOffset = uint(v)
			}
			uploadExpiresRaw := resp.Header.Get("Uploadexpires")
			if uploadExpiresRaw != "" {
				uploadExpires = &uploadExpiresRaw
			}
			if err != nil {
				return nil, goahttp.ErrValidationError("upload", "patch", err)
			}
			res := NewPatchResultNoContent(tusResumable, uploadOffset, uploadExpires)
			return res, nil
		case http.StatusUnsupportedMediaType:
			var (
				body PatchInvalidContentTypeResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("upload", "patch", err)
			}
			err = ValidatePatchInvalidContentTypeResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("upload", "patch", err)
			}
			return nil, NewPatchInvalidContentType(&body)
		case http.StatusConflict:
			var (
				body PatchInvalidOffsetResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("upload", "patch", err)
			}
			err = ValidatePatchInvalidOffsetResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("upload", "patch", err)
			}
			return nil, NewPatchInvalidOffset(&body)
		case http.StatusNotFound:
			var (
				body PatchNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("upload", "patch", err)
			}
			err = ValidatePatchNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("upload", "patch", err)
			}
			return nil, NewPatchNotFound(&body)
		case http.StatusBadRequest:
			var (
				body PatchInvalidChecksumAlgorithmResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("upload", "patch", err)
			}
			err = ValidatePatchInvalidChecksumAlgorithmResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("upload", "patch", err)
			}
			return nil, NewPatchInvalidChecksumAlgorithm(&body)
		case 460:
			var (
				body PatchChecksumMismatchResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("upload", "patch", err)
			}
			err = ValidatePatchChecksumMismatchResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("upload", "patch", err)
			}
			return nil, NewPatchChecksumMismatch(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("upload", "patch", resp.StatusCode, string(body))
		}
	}
}

// BuildOptionsRequest instantiates a HTTP request object with method and path
// set to call the "upload" service "options" endpoint
func (c *Client) BuildOptionsRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: OptionsUploadPath()}
	req, err := http.NewRequest("OPTIONS", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("upload", "options", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeOptionsResponse returns a decoder for responses returned by the upload
// options endpoint. restoreBody controls whether the response body should be
// restored after having been read.
func DecodeOptionsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			var (
				tusResumable         string
				tusVersion           string
				tusExtension         string
				tusMaxSize           *uint
				tusChecksumAlgorithm string
				err                  error
			)
			tusResumableRaw := resp.Header.Get("Tusresumable")
			if tusResumableRaw == "" {
				err = goa.MergeErrors(err, goa.MissingFieldError("tusResumable", "header"))
			}
			tusResumable = tusResumableRaw
			tusVersionRaw := resp.Header.Get("Tusversion")
			if tusVersionRaw == "" {
				err = goa.MergeErrors(err, goa.MissingFieldError("tusVersion", "header"))
			}
			tusVersion = tusVersionRaw
			if !(tusVersion == "1.0.0") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("tusVersion", tusVersion, []interface{}{"1.0.0"}))
			}
			tusExtensionRaw := resp.Header.Get("Tusextension")
			if tusExtensionRaw == "" {
				err = goa.MergeErrors(err, goa.MissingFieldError("tusExtension", "header"))
			}
			tusExtension = tusExtensionRaw
			if !(tusExtension == "creation,creation-with-upload,creation-defer-length,expiration,checksum,termination") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("tusExtension", tusExtension, []interface{}{"creation,creation-with-upload,creation-defer-length,expiration,checksum,termination"}))
			}
			{
				tusMaxSizeRaw := resp.Header.Get("Tusmaxsize")
				if tusMaxSizeRaw != "" {
					v, err2 := strconv.ParseUint(tusMaxSizeRaw, 10, strconv.IntSize)
					if err2 != nil {
						err = goa.MergeErrors(err, goa.InvalidFieldTypeError("tusMaxSize", tusMaxSizeRaw, "unsigned integer"))
					}
					pv := uint(v)
					tusMaxSize = &pv
				}
			}
			tusChecksumAlgorithmRaw := resp.Header.Get("Tuschecksumalgorithm")
			if tusChecksumAlgorithmRaw == "" {
				err = goa.MergeErrors(err, goa.MissingFieldError("tusChecksumAlgorithm", "header"))
			}
			tusChecksumAlgorithm = tusChecksumAlgorithmRaw
			if !(tusChecksumAlgorithm == "md5,sha1,crc32") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("tusChecksumAlgorithm", tusChecksumAlgorithm, []interface{}{"md5,sha1,crc32"}))
			}
			if err != nil {
				return nil, goahttp.ErrValidationError("upload", "options", err)
			}
			res := NewOptionsResultNoContent(tusResumable, tusVersion, tusExtension, tusMaxSize, tusChecksumAlgorithm)
			return res, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("upload", "options", resp.StatusCode, string(body))
		}
	}
}

// BuildPostRequest instantiates a HTTP request object with method and path set
// to call the "upload" service "post" endpoint
func (c *Client) BuildPostRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: PostUploadPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("upload", "post", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodePostRequest returns an encoder for requests sent to the upload post
// server.
func EncodePostRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*upload.PostPayload)
		if !ok {
			return goahttp.ErrInvalidType("upload", "post", "*upload.PostPayload", v)
		}
		req.Header.Set("tusResumable", p.TusResumable)
		if p.UploadDeferLength != nil {
			req.Header.Set("uploadDeferLength", *p.UploadDeferLength)
		}
		if p.UploadChecksum != nil {
			req.Header.Set("uploadChecksum", *p.UploadChecksum)
		}
		if p.TusMaxSize != nil {
			req.Header.Set("tusMaxSize", *p.TusMaxSize)
		}
		body := p
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("upload", "post", err)
		}
		return nil
	}
}

// DecodePostResponse returns a decoder for responses returned by the upload
// post endpoint. restoreBody controls whether the response body should be
// restored after having been read.
// DecodePostResponse may return the following errors:
//	- "InvalidDeferLength" (type *goa.ServiceError): http.StatusBadRequest
//	- "InvalidChecksumAlgorithm" (type *goa.ServiceError): http.StatusBadRequest
//	- "MaximumSizeExceeded" (type *goa.ServiceError): http.StatusRequestEntityTooLarge
//	- "ChecksumMismatch" (type *goa.ServiceError): 460
//	- error: internal error
func DecodePostResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				location      string
				tusResumable  string
				uploadOffset  string
				uploadExpires *string
				err           error
			)
			locationRaw := resp.Header.Get("Location")
			if locationRaw == "" {
				err = goa.MergeErrors(err, goa.MissingFieldError("location", "header"))
			}
			location = locationRaw
			err = goa.MergeErrors(err, goa.ValidateFormat("location", location, goa.FormatURI))

			tusResumableRaw := resp.Header.Get("Tusresumable")
			if tusResumableRaw == "" {
				err = goa.MergeErrors(err, goa.MissingFieldError("tusResumable", "header"))
			}
			tusResumable = tusResumableRaw
			uploadOffsetRaw := resp.Header.Get("Uploadoffset")
			if uploadOffsetRaw == "" {
				err = goa.MergeErrors(err, goa.MissingFieldError("uploadOffset", "header"))
			}
			uploadOffset = uploadOffsetRaw
			uploadExpiresRaw := resp.Header.Get("Uploadexpires")
			if uploadExpiresRaw != "" {
				uploadExpires = &uploadExpiresRaw
			}
			if err != nil {
				return nil, goahttp.ErrValidationError("upload", "post", err)
			}
			res := NewPostResultCreated(location, tusResumable, uploadOffset, uploadExpires)
			return res, nil
		case http.StatusBadRequest:
			en := resp.Header.Get("goa-error")
			switch en {
			case "InvalidDeferLength":
				var (
					body PostInvalidDeferLengthResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("upload", "post", err)
				}
				err = ValidatePostInvalidDeferLengthResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("upload", "post", err)
				}
				return nil, NewPostInvalidDeferLength(&body)
			case "InvalidChecksumAlgorithm":
				var (
					body PostInvalidChecksumAlgorithmResponseBody
					err  error
				)
				err = decoder(resp).Decode(&body)
				if err != nil {
					return nil, goahttp.ErrDecodingError("upload", "post", err)
				}
				err = ValidatePostInvalidChecksumAlgorithmResponseBody(&body)
				if err != nil {
					return nil, goahttp.ErrValidationError("upload", "post", err)
				}
				return nil, NewPostInvalidChecksumAlgorithm(&body)
			default:
				body, _ := ioutil.ReadAll(resp.Body)
				return nil, goahttp.ErrInvalidResponse("upload", "post", resp.StatusCode, string(body))
			}
		case http.StatusRequestEntityTooLarge:
			var (
				body PostMaximumSizeExceededResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("upload", "post", err)
			}
			err = ValidatePostMaximumSizeExceededResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("upload", "post", err)
			}
			return nil, NewPostMaximumSizeExceeded(&body)
		case 460:
			var (
				body PostChecksumMismatchResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("upload", "post", err)
			}
			err = ValidatePostChecksumMismatchResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("upload", "post", err)
			}
			return nil, NewPostChecksumMismatch(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("upload", "post", resp.StatusCode, string(body))
		}
	}
}

// BuildDeleteRequest instantiates a HTTP request object with method and path
// set to call the "upload" service "delete" endpoint
func (c *Client) BuildDeleteRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		id string
	)
	{
		p, ok := v.(*upload.DeletePayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("upload", "delete", "*upload.DeletePayload", v)
		}
		id = p.ID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DeleteUploadPath(id)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("upload", "delete", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDeleteRequest returns an encoder for requests sent to the upload
// delete server.
func EncodeDeleteRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*upload.DeletePayload)
		if !ok {
			return goahttp.ErrInvalidType("upload", "delete", "*upload.DeletePayload", v)
		}
		req.Header.Set("tusResumable", p.TusResumable)
		return nil
	}
}

// DecodeDeleteResponse returns a decoder for responses returned by the upload
// delete endpoint. restoreBody controls whether the response body should be
// restored after having been read.
// DecodeDeleteResponse may return the following errors:
//	- "NotFound" (type *goa.ServiceError): http.StatusNotFound
//	- error: internal error
func DecodeDeleteResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			var (
				tusResumable string
				err          error
			)
			tusResumableRaw := resp.Header.Get("Tusresumable")
			if tusResumableRaw == "" {
				err = goa.MergeErrors(err, goa.MissingFieldError("tusResumable", "header"))
			}
			tusResumable = tusResumableRaw
			err = goa.MergeErrors(err, goa.ValidatePattern("tusResumable", tusResumable, "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(-(0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(\\.(0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*)?(\\+[0-9a-zA-Z-]+(\\.[0-9a-zA-Z-]+)*)?$"))
			if err != nil {
				return nil, goahttp.ErrValidationError("upload", "delete", err)
			}
			res := NewDeleteResultNoContent(tusResumable)
			return res, nil
		case http.StatusNotFound:
			var (
				body DeleteNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("upload", "delete", err)
			}
			err = ValidateDeleteNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("upload", "delete", err)
			}
			return nil, NewDeleteNotFound(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("upload", "delete", resp.StatusCode, string(body))
		}
	}
}
